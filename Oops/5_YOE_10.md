### 1. How does Kotlin’s "everything is an object" approach impact performance compared to Java's primitives?
```
- While kotlin treat `Int, Boolean, Char, Float, Double` as an object, but Kotlin compiler optimized them into jvm primitives to save memory
- Kotlins object Data Types mapped to java premitives and saves memory.
- if kotlin Data Types are surrounded by nullable, generics, or list then it does not convert to jvm premitives, and it uses extra memory in heap
- Ex. Kotlin compiler converts `Int` to `int` but does not convert `Int?` to nullable `int`
```

--- 

### 2. Difference between "Inheritance" and "Composition"? Which is preferred in Android?
```
- Inhetitance: (Is-A relation, )
  --> subClass is-a child class of parent class,
  --> Only one object is created in memory which contains all properties of both classes,
  --> if child class object destroy then parent also destroy
```

#### Ex. Inheritance
```
open class Person {}
class Student : Person() {}
```

```
- Composition: (Has-A relation, (PRE-FERRED))
  --> class has-a referance of other class,
  --> If You have 2 seperate objects,
  --> if Object A hold referance of object B,
  --> if Obj A is destroy then object B will destroy only if no-one is using it, else it is live for other object which holds its referrence
  --> Ex. DI, LinkedList Node has-a referance of next node, same for Graph
```
#### Ex. Composition (Person has-a work)
```
class Person(private val work:Work)
```
---

### 3. How do you implement a "Diamond Problem" solution in Kotlin using Interfaces?
```
- Kotlin allows interfaces to have default method implementation
- If class implements 2 interface with same method name
- then compiler force to override method by calling parent interface
```
```
interface Person {}
interface Student : Person {
    fun enjoy() {}
}
interface Employee : Person {
    fun enjoy() {}
}
class Work: Student, Employee {
    override fun enjoy() {
        super<Student>.enjoy() <-- It resolves ambiguity
    }
}
```
---
### 4. Explain "Encapsulation" vs "Abstraction" with an Android example.
```
- Encapsulation:
  --> Restricting direct access to internal state
  --> Hiding internal Properties and exposing them via getter methods 
  --> Controlling internal states and behaviours by getter and setter methods
  --> Ex. Private MutableLiveData exposes by public LiveData instance
```
Ex. 
```
class LoginViewModel: ViewModel() {
    
    //Disallow from external source to directly modify or change value
    private var _credentials: MutableLiveData<Credentials>()
    
    //Exposing data by getter method (read only)        
    val credentials: LiveData<Credentials> = _credentials
}
```

```
- Abstraction:
  --> Exposing essential behavior
  --> Hiding how it’s implemented
  --> Repository Pattern in Android
  --> Using Repository, ViewModel know it is getting data but dont know from where (from room or api call or other src)
```












































